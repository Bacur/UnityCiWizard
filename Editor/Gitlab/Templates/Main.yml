stages:
  - prepare
  - test
  - build
  - after_build
  - deploy

variables:
  UCI_CFG_PROJECT_PATH: "{{ project_path }}"
  
.check-environment-variables: &check-environment-variables
  - |-
    unset CI_VAR_FAILURE_MESSAGE
    CI_VAR_FAILURE_CODE=1
    trap 'status=$?; if [ "$status" -eq "$CI_VAR_FAILURE_CODE" ] && [ -n "$CI_VAR_FAILURE_MESSAGE" ]; then echo -e "\e[31mERROR: $CI_VAR_FAILURE_MESSAGE\e[0m" >&2; fi' EXIT

    if [ "${CI_COMMIT_REF_PROTECTED}" != "true" ]; then
      CI_VAR_FAILURE_MESSAGE="Current branch is not protected. Configure the branch as protected in GitLab."
      exit $CI_VAR_FAILURE_CODE
    fi
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:check-environment-variables_section[collapsed=true]\r\e[0Kcheck-environment-variables\e[0m"  
    if [ -z "${UCI_ENV_UNITY_HUB_COMMAND}" ]; then
      CI_VAR_FAILURE_MESSAGE="Variable UCI_ENV_UNITY_HUB_COMMAND is not set or empty"
      exit $CI_VAR_FAILURE_CODE
    fi
    if [ -z "${UCI_ENV_UNITY_EXECUTABLE+set}" ]; then
      CI_VAR_FAILURE_MESSAGE="Variable UCI_ENV_UNITY_EXECUTABLE is not set"
      exit $CI_VAR_FAILURE_CODE
    fi
    if [ -z "${UCI_ENV_UNITY_USERNAME}" ]; then
      CI_VAR_FAILURE_MESSAGE="Variable UCI_ENV_UNITY_USERNAME is not set or empty"
      exit $CI_VAR_FAILURE_CODE
    fi
    if [ -z "${UCI_ENV_UNITY_PASSWORD}" ]; then
      CI_VAR_FAILURE_MESSAGE="Variable UCI_ENV_UNITY_PASSWORD is not set or empty"
      exit $CI_VAR_FAILURE_CODE
    fi
    if [ -z "${UCI_ENV_UNITY_SERIAL}" ]; then
      CI_VAR_FAILURE_MESSAGE="Variable UCI_ENV_UNITY_SERIAL is not set or empty"
      exit $CI_VAR_FAILURE_CODE
    fi
    trap - EXIT
    unset CI_VAR_FAILURE_MESSAGE CI_VAR_FAILURE_CODE
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:check-environment-variables_section\r\e[0K\e[0m"

.set_project_path: &set_project_path
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:set_project_path_section[collapsed=true]\r\e[0Kset_project_path\e[0m"  
    if [ "$UCI_CFG_PROJECT_PATH" == "." ]; then
        UCI_VAR_UNITY_FULL_PROJECT_PATH=${PWD}
    else
        UCI_VAR_UNITY_FULL_PROJECT_PATH="${PWD}/${UCI_CFG_PROJECT_PATH}"
    fi
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:set_project_path_section\r\e[0K\e[0m"

.unity-get-project-version: &unity-get-project-version
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:unity-get-project-version_section[collapsed=true]\r\e[0Kunity-get-project-version\e[0m"  
    UCI_VAR_PROJECT_VERSION=$(awk '{for(i=1;i<=NF;i++){if($i~/([0-9A-Za-z]+(\.[0-9A-Za-z]+)+)/) {print $i;exit;}}}' $UCI_CFG_PROJECT_PATH/ProjectSettings/ProjectVersion.txt)
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:unity-get-project-version_section\r\e[0K\e[0m"

.unity-check-install-editor: &unity-check-install-editor
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:&unity-check-install-editor_section[collapsed=true]\r\e[0Kunity-check-install-editor\e[0m"  
    UCI_VAR_UNITY_EDITOR_PATH=$("$UCI_ENV_UNITY_HUB_COMMAND" --headless editors -i | awk -v ver="$UCI_VAR_PROJECT_VERSION" '$0~ver{print}' | awk 'match($0,/installed at [^ ]*/){ print substr($0, RSTART + 13, RLENGTH)}')
    if [ -z "$UCI_VAR_UNITY_EDITOR_PATH" ]; then 
      UCI_VAR_INSTALL_LOCKFILE="/tmp/${UCI_VAR_PROJECT_VERSION}.lock"
      if [ ! -f "$UCI_VAR_INSTALL_LOCKFILE" ]; then
        touch "$UCI_VAR_INSTALL_LOCKFILE"
        UCI_VAR_PROJECT_CHANGESET=$(awk '{for(i=1;i<=NF;i++){if($i~/\([0-9A-Za-z]+\)/) {print substr($i, 2, length($i)-2)}}}' $UCI_CFG_PROJECT_PATH/ProjectSettings/ProjectVersion.txt)
        "$UCI_ENV_UNITY_HUB_COMMAND" --headless install --version "$UCI_VAR_PROJECT_VERSION" --changeset "$UCI_VAR_PROJECT_CHANGESET"
        rm "$UCI_VAR_INSTALL_LOCKFILE"
      else
        while [ -f "$UCI_VAR_INSTALL_LOCKFILE" ]
        do
          sleep 1m
          echo "Waiting for another job to install Editor"
        done
      fi
      UCI_VAR_UNITY_EDITOR_PATH=$("$UCI_ENV_UNITY_HUB_COMMAND" --headless editors -i | awk -v ver="$UCI_VAR_PROJECT_VERSION" '$0~ver{print}' | awk 'match($0,/installed at [^ ]*/){ print substr($0, RSTART + 13, RLENGTH)}')
    fi
    echo "UCI_VAR_UNITY_EDITOR_PATH=$UCI_VAR_UNITY_EDITOR_PATH" >> $GITLAB_ENV
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:unity-check-install-editor_section\r\e[0K\e[0m"
    
.unity-check-install-modules: &unity-check-install-modules
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:unity-check-install-modules_section[collapsed=true]\r\e[0Kunity-check-install-modules\e[0m"  
    if [ -n "$UCI_CFG_JOB_UNITY_MODULES" ]; then 
      UCI_VAR_INSTALL_LOCKFILE="/tmp/${UCI_VAR_PROJECT_VERSION}_${UCI_CFG_JOB_UNITY_MODULES}.lock"
      if [ ! -f "$UCI_VAR_INSTALL_LOCKFILE" ]; then
        touch "$UCI_VAR_INSTALL_LOCKFILE"
        "$UCI_ENV_UNITY_HUB_COMMAND" --headless install-modules --version "$UCI_VAR_PROJECT_VERSION" --cm -m ${UCI_CFG_JOB_UNITY_MODULES} || echo "No modules to install"
        rm "$UCI_VAR_INSTALL_LOCKFILE"
      else
        while [ -f "$UCI_VAR_INSTALL_LOCKFILE" ]
        do
          sleep 10s
          echo "Waiting for another job to install modules"
        done
      fi
    fi
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:unity-check-install-modules_section\r\e[0K\e[0m"
    
.unity-import-section-start: &unity-import-section-start
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:import_section\r\e[0KStart importing project\e[0m"  

.unity-import-section-end: &unity-import-section-end
  - |-
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:import_section\r\e[0K\e[0m" 

#bee_backend workaround (https://discussions.unity.com/t/linux-editor-stuck-on-loading-because-of-bee_backend-w-workaround/854480/37)
.unity-apply-bee-workaround: &unity-apply-bee-workaround
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:unity-apply-bee-workaround_section[collapsed=true]\r\e[0Kunity-apply-bee-workaround\e[0m"  
    UCI_VAR_UNITY_EDITOR_PARENT_PATH="$(dirname "$UCI_VAR_UNITY_EDITOR_PATH")"
    find $UCI_VAR_UNITY_EDITOR_PARENT_PATH -name 'bee_backend' -type f -print0 | 
    while IFS= read -r -d '' line; do 
      UCI_VAR_BEE_EXECUTABLE=$line
      UCI_VAR_BEE_REAL_EXECUTABLE="${UCI_VAR_BEE_EXECUTABLE}_real"
      if [ ! -f "$UCI_VAR_BEE_REAL_EXECUTABLE" ]; then
        mv "$UCI_VAR_BEE_EXECUTABLE" "$UCI_VAR_BEE_REAL_EXECUTABLE"
        cat > "$UCI_VAR_BEE_EXECUTABLE" <<'EOF'
    #! /bin/bash
    args=("$@")
    for ((i=0; i<"${#args[@]}"; ++i))
    do
        case ${args[i]} in
            --stdin-canary)
                unset args[i];
                break;;
        esac
    done
    ${0}_real "${args[@]}"
    EOF
        chmod +x "$UCI_VAR_BEE_EXECUTABLE"
      fi
    done
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:unity-apply-bee-workaround_section\r\e[0K\e[0m"
    
.unity-set-batch-mode-arguments: &unity-set-batch-mode-arguments
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:unity-set-batch-mode-arguments_section[collapsed=true]\r\e[0Kunity-set-batch-mode-arguments\e[0m"  
    if [ "$UCI_CFG_PROJECT_PATH" == "." ]; then
      UCI_VAR_UNITY_FULL_PROJECT_PATH=${PWD}
    else
      UCI_VAR_UNITY_FULL_PROJECT_PATH="${PWD}/${UCI_CFG_PROJECT_PATH}"
    fi
    UCI_VAR_UNITY_BATCH_MODE_ARGUMENTS="-projectPath ${UCI_VAR_UNITY_FULL_PROJECT_PATH} -batchmode -silent-crashes -logFile -"
    UCI_VAR_UNITY_BATCH_MODE_ARGUMENTS="${UCI_VAR_UNITY_BATCH_MODE_ARGUMENTS} -username ${UCI_ENV_UNITY_USERNAME} -password ${UCI_ENV_UNITY_PASSWORD} -serial ${UCI_ENV_UNITY_SERIAL}"
    echo 'UCI_VAR_UNITY_BATCH_MODE_ARGUMENTS="$UCI_VAR_UNITY_BATCH_MODE_ARGUMENT"' >> $GITLAB_ENV
    mkdir -p /tmp/unity_license/
    touch "/tmp/unity_license/license_job_$CI_JOB_ID"
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:unity-set-batch-mode-arguments_section\r\e[0K\e[0m"

.unity-apply-job-call-arguments: &unity-apply-job-call-arguments
  - |-
    echo -e "\e[96m\e[0Ksection_start:`date +%s`:unity-apply-job-call-arguments_section[collapsed=true]\r\e[0Kunity-apply-job-call-arguments\e[0m"  
    UCI_VAR_UNITY_BATCH_MODE_ARGUMENTS="${UCI_VAR_UNITY_BATCH_MODE_ARGUMENTS} -quit -executeMethod CiWizard.Editor.CiConfig.Execute"
    echo -e "\e[96m\e[0Ksection_end:`date +%s`:unity-apply-job-call-arguments_section\r\e[0K\e[0m"

.unity-after-cleanup: &unity-after-cleanup |-
    if [ "$CI_JOB_STATUS" != "success" ]; then
      exit 0
    fi
    LICENSE_FILE="/tmp/unity_license/license_job_$CI_JOB_ID"
    if [ -f "$LICENSE_FILE" ]; then
      rm "$LICENSE_FILE"
    fi
    UCI_VAR_LICENSE_TMP_COUNT=$(find /tmp/unity_license -type f -name "license_job_*" | wc -l | tr -d ' ')
    echo "Processes using license: $UCI_VAR_LICENSE_TMP_COUNT"
    if [[ $UCI_VAR_LICENSE_TMP_COUNT == 0 ]]; then
      echo "Return license"
      "$UCI_VAR_UNITY_EDITOR_PATH""$UCI_ENV_UNITY_EXECUTABLE" -quit -batchmode -username ${UCI_ENV_UNITY_USERNAME} -password ${UCI_ENV_UNITY_PASSWORD} -returnlicense -logFile -
    fi

.unity: &unity
  after_script:
    - *unity-after-cleanup

{{~ for job in jobs ~}}
{{include job.template_file_name}}

{{~ end ~}}
